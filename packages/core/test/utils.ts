import nfs from 'node:fs'
import path from 'node:path'
import { randomUUID } from 'node:crypto'
import { it, assert, expect } from 'vitest'
import fs from 'fs-extra'
import type { SetRequired } from 'type-fest'
import createDebugger from 'debug'
import { definePreset } from '../src'
import { createPresetContext } from '../src/context'
import type { PresetOptions, LocalPreset, ApplyOptions } from '../src'

export interface DirectoryStructure {
	[path: string]: { type: 'file'; content?: any; json?: any } | { type: 'directory' } | { type: 'none' }
}

export const debug = createDebugger('preset:tests')
export const fixturesDirectory = path.resolve(__dirname, './__fixtures__')
export const cleanupFixtures = async(fixtures: string = fixturesDirectory) => await fs.rm(fixtures, { force: true, recursive: true, maxRetries: 3, retryDelay: 1000 })
export const presetFixture = (name: string) => path.resolve(__dirname, './fixtures', name)

/**
 * Creates a test preset.
 */
export const makeTestPreset = async(
	customPresetOptions: SetRequired<Partial<PresetOptions>, 'handler'>,
	customApplyOptions?: Partial<ApplyOptions>,
	customLocalPreset?: Partial<LocalPreset>,
) => {
	const preset = definePreset({
		name: 'test-preset',
		flags: {
			test: true,
		},
		...customPresetOptions,
	})

	const context = await createPresetContext(preset, {
		resolvable: '',
		args: [],
		targetDirectory: '',
		...customApplyOptions,
	}, {
		presetFile: '',
		rootDirectory: '',
		...customLocalPreset,
	})

	return { preset, context, executePreset: async() => preset.apply(context) }
}

/**
 * Expect the given directory to match the given structure.
 */
export async function expectStructureMatches(directory: string, ds: DirectoryStructure) {
	debug(`Asserting structure in ${directory}.`)

	for (const [relativePathToEntry, entry] of Object.entries(ds)) {
		const pathToEntry = path.resolve(directory, relativePathToEntry)

		if (entry.type === 'none') {
			assert.isFalse(fs.pathExistsSync(pathToEntry), `${pathToEntry} actually exists although it should not.`)
		}

		if (entry.type === 'file') {
			assert.isTrue(nfs.statSync(pathToEntry, { throwIfNoEntry: false })?.isFile(), `${pathToEntry} is not a file or does not exist`)

			if (entry.content) {
				expect(fs.readFileSync(pathToEntry, { encoding: 'utf-8' })).toBe(entry.content)
			}

			if (entry.json) {
				expect(fs.readJsonSync(pathToEntry)).toMatchObject(entry.json)
			}
		}

		if (entry.type === 'directory') {
			assert.isTrue(nfs.statSync(pathToEntry, { throwIfNoEntry: false })?.isDirectory(), `${pathToEntry} is not a directory or does not exist`)
		}
	}
}

/**
 * Generates the given directory structure.
 */
export async function generateStructure(directory: string, ds?: DirectoryStructure) {
	if (!ds) {
		return
	}

	debug(`Generating structure in ${directory}.`)

	for (const [relativePathToEntry, entry] of Object.entries(ds)) {
		const pathToEntry = path.resolve(directory, relativePathToEntry)

		if (entry.type === 'file') {
			debug(`Writing file to ${pathToEntry}.`)
			await fs.ensureFile(pathToEntry)
			await fs.writeFile(pathToEntry, entry.content ?? '// Generated by preset')
		}

		if (entry.type === 'directory') {
			debug(`Making directory to ${pathToEntry}.`)
			await fs.ensureDir(pathToEntry)
		}
	}
}

export interface SandboxOptions {
	fn: (d: { sandboxDirectory: string; targetDirectory: string; rootDirectory: string }, proxyMakeTestPreset: typeof makeTestPreset) => Promise<void>
	rootStructure?: DirectoryStructure
	targetStructure?: DirectoryStructure
	cleanup?: boolean
}

/**
 * Creates a testing directory and a preset inside it.
 */
export async function usingSandbox({ fn, rootStructure, targetStructure, cleanup }: SandboxOptions) {
	const sandboxDirectory = path.resolve(fixturesDirectory, randomUUID())
	const targetDirectory = path.resolve(sandboxDirectory, 'preset-target')
	const rootDirectory = path.resolve(sandboxDirectory, 'preset-root')
	const proxyMakeTestPreset: typeof makeTestPreset = (presetOptions, applyOptions, fs) => makeTestPreset(
		presetOptions,
		{ targetDirectory, ...applyOptions },
		{ rootDirectory, ...fs },
	)

	try {
		debug(`Making sandbox in ${sandboxDirectory}.`)
		await fs.ensureDir(targetDirectory)
		await fs.ensureDir(rootDirectory)
		await generateStructure(rootDirectory, rootStructure)
		await generateStructure(targetDirectory, targetStructure)

		debug('Running sandbox handler.')
		await fn({ sandboxDirectory, targetDirectory, rootDirectory }, proxyMakeTestPreset)
	} finally {
		if (cleanup !== false) {
			await cleanupFixtures(sandboxDirectory)
		}
	}
}

export function dedent(
	templ: TemplateStringsArray | string,
	...values: unknown[]
): string {
	let strings = Array.from(typeof templ === 'string' ? [templ] : templ)

	// 1. Remove trailing whitespace.
	strings[strings.length - 1] = strings[strings.length - 1].replace(
		/\r?\n([\t ]*)$/,
		'',
	)

	// 2. Find all line breaks to determine the highest common indentation level.
	const indentLengths = strings.reduce((arr, str) => {
		const matches = str.match(/\n([\t ]+|(?!\s).)/g)
		if (matches) {
			return arr.concat(
				matches.map((match) => match.match(/[\t ]/g)?.length ?? 0),
			)
		}

		return arr
	}, <number[]>[])

	// 3. Remove the common indentation from all strings.
	if (indentLengths.length) {
		const pattern = new RegExp(`\n[\t ]{${Math.min(...indentLengths)}}`, 'g')

		strings = strings.map((str) => str.replace(pattern, '\n'))
	}

	// 4. Remove leading whitespace.
	strings[0] = strings[0].replace(/^\r?\n/, '')

	// 5. Perform interpolation.
	let string = strings[0]

	values.forEach((value, i) => {
		// 5.1 Read current indentation level
		const endentations = string.match(/(?:^|\n)( *)$/)
		const endentation = endentations ? endentations[1] : ''
		let indentedValue = value
		// 5.2 Add indentation to values with multiline strings
		if (typeof value === 'string' && value.includes('\n')) {
			indentedValue = String(value)
				.split('\n')
				.map((str, i) => {
					return i === 0 ? str : `${endentation}${str}`
				})
				.join('\n')
		}

		string += indentedValue + strings[i + 1]
	})

	return string
}

export interface TestRecord {
	skip?: boolean
	only?: boolean
}

export function testsInSandbox<T extends TestRecord>(tests: Record<string, T>, options: (test: T, name: string) => SandboxOptions) {
	for (const [name, test] of Object.entries(tests)) {
		const callback = async() => await usingSandbox(options(test, name))

		if (test.skip === true) {
			it.skip(name, async() => {})
			continue
		}

		if (test.only === true) {
			it.only(name, callback)
			continue
		}

		it(name, callback)
	}
}
